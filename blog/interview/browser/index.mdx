---
title: "面试复习题 - 浏览器相关"
date: "2022-12-24"
tags: ["interview"]
embeddedImagesLocal:
  - ./browser_cache.png
---

import { getImage, GatsbyImage } from 'gatsby-plugin-image';

## 浏览器的重排与重绘

- <mark>重排/回流（reflow）</mark>: 当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。
- <mark>重绘（repaint）</mark>: 当一个元素的外观发生变化，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。

单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。
重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。

> 『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。

### 如何触发重排和重绘

任何改变用来构建渲染树的信息都会导致一次重排或者重绘：

- 添加、删除、更新 DOM 节点
- 通过 `display: none` 隐藏一个 DOM 节点
- 通过 `visibility: hidden` 隐藏一个 DOM 节点 - 只触发重绘，因为没有任何几何变化，渲染树也没有改变
- 移动或者给页面的 DOM 节点添加动画
- 添加一个样式表，调整样式属性
- 用户行为，例如调整窗口大小，改变字号，或者滚动。


### 如何避免重绘或者重排

- 集中改变样式，不要一条一条的修改 DOM 的样式。
- 不要把 DOM 节点的属性值放在循环里当作循环的变量。
- 为动画的 HTML 元素使用 `fixed` 或 `absolut` 的 `position`，那么修改他们 CSS 是不会重排的。
- 不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。
- 尽量只修改 `position: absolute` 或 `fixed` 的元素，对其他元素影响不大。<mark>同3</mark>。
- 动画开启 <mark>GPU</mark> 加速，<mark>translate</mark> 使用 <mark>3D</mark> 变化。
-  提升为合成层:
    - 合成层的位图，会交由 GPU 合成，比 CPU 处理要快
    - 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
    - 对于 transform 和 opacity 效果，不会触发 layout 和 paint

```css
#target {
    will-change: transform;
}
```


## 浏览器缓存机制

<GatsbyImage alt='browser cache' image={getImage(props.localImages[0])} title='browser cache'/>

- 浏览器每次发起请求，都会 <mark>先在浏览器缓存中查找该请求的结果以及缓存标识</mark>
- 浏览器每次拿到返回的请求结果都会 <mark>将该结果和缓存标识存入浏览器缓存中</mark>

浏览器缓存分为两种：

<mark>**协商缓存**</mark>:
> 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。

同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：`Last-Modified / If-Modified-Since` 和 `Etag / If-None-Match`，其中 `Etag / If-None-Match` 的优先级比 `Last-Modified / If-Modified-Since` 高。协商缓存主要有以下两种情况：

- 协商缓存生效，返回 304
- 协商缓存失效，返回 200 和请求结果结果


<mark>**强制缓存**</mark>:
> 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。

当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 `Expires` 和 `Cache-Control`，其中 `Cache-Control` 优先级比 `Expires` 高。
强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：

- 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。
- 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。
- 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果
